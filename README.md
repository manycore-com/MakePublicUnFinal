# MakePublicUnFinal
Makes everything public and not final in java .class / .jar / .war files.

This is useful if you would like to experiment with java bytecode modifications.

It produces a Jar with the following flags

```Options:
    --inClassDir -> directory root with input .class files { String }
    --outClassDir -> directory root with output .class files. Can be same as --inClassDir { String }
    --inJarDir -> directory root with input .jar files, or point to a jar file directly { String }
    --outJarDir -> directory root with output .jar files. Can be same as --inClassDir { String }
    --inDexDir -> directory root with input .dex files, or point to a dex file directly { String }
    --outDexDir -> directory root with output .dex files. Can be same as --inDexDir { String }
    --minSdkVersion -> What sdk level to generate DEX { Int }
    --help, -h -> Usage info 
```

## Convert my newly compiled classes to public when I build
Add this to your app/build.gradle, with path/MakePublicUnfinal.main.jar replaced
with path to the jar generated by this project.

```
tasks.whenTaskAdded { task ->
    if (false && task.name.startsWith("compile") && task.name.endsWith("JavaWithJavac")) {
        task.doLast {
            println("rauk " + it.getClass())
            def sout = new StringBuilder()
            def serr = new StringBuilder()
            def proc = ['/usr/bin/java', '-jar', '/path/to/MakePrivateTmp/out/artifacts/MakePrivateTmp_jar/MakePrivateTmp.jar', '--inClassDir', '/path/to/project/app/build/intermediates/javac', '--outClassDir', '/path/to/project/app/build/intermediates/javac'].execute()
            proc.consumeProcessOutput(sout, serr)
            proc.waitForOrKill(10000)
            if (0 != proc.exitValue()) {
                println "fail converting class"
                throw new GradleException(serr.toString())
            }
            println "done converting class"
        }
    }
}
```



## How do I copy all dependencies?
like Maven's copy-dependencides
```
//copy paste from https://proandroiddev.com/how-to-extract-your-android-projects-dependencies-with-a-gradle-task-1775e8c21093
android.applicationVariants.all { variant ->
    task "copyDependencies${variant.name.capitalize()}"() {
        outputs.upToDateWhen { false }
        doLast {
            println "Executing copyDependencies${variant.name.capitalize()}"
            variant.getCompileClasspath().each { fileDependency ->
                def sourcePath = fileDependency.absolutePath
                def destinationPath = project.projectDir.path + "/build/dependencies/${variant.name}/"
                println "Copying dependency:"
                println sourcePath

//The monstrous regex that gets the name of the lib from itâ€™s exploded .aar path
                def dependencyName
                if (sourcePath.contains("classes.jar")) {
                    def dependencyNameRegexResult = (sourcePath =~ /.*\/(.*)\.aar\/.*\/jars\/classes\.jar/)
                    if (dependencyNameRegexResult.size() > 0) {
                        dependencyName = dependencyNameRegexResult[0][1]
                        println "Exploded AAR found : ${dependencyName}"
                    }
                }

                copy {
                    from sourcePath
                    into destinationPath

                    rename {String filename ->
                        if (filename.contains("classes.jar") && dependencyName != null) {
                            dependencyName = "${dependencyName}.jar"
                            println "Renaming dependency file to : ${dependencyName}"
                            return dependencyName
                        }
                        return filename
                    }
                }
            }
        }
    }
}

```