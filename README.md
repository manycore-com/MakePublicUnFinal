# MakePublicUnFinal
Makes everything public and not final in java .class / .jar / .war files.

This is useful if you would like to experiment with java bytecode modifications.

It produces a Jar with the following flags

```Options:
--inClassDir -> directory root with input .class files { String }
--outClassDir -> directory root with output .class files. Can be same as --inClassDir { String }
--inJarDir -> directory root with input .jar files, or point to a jar file directly { String }
--outJarDir -> directory root with output .jar files. Can be same as --inClassDir { String }
--help, -h -> Usage info 
```

## Convert my newly compiled classes to public when I build
Add this to your app/build.gradle, with path/MakePublicUnfinal.main.jar replaced
with path to the jar generated by this project.

```
task publicAndUnFinal {
    doLast {
  
// If you want to backup the files first    
//        def outDir = new File('/tmp')
//        outDir.listFiles().each { theFile ->
//            if (theFile.isDirectory()) {
//                copy {
//                    from '/home/ehsmeng/AndroidStudioProjects/ThreadSecurity/copyClasses'
//                    into theFile.path + File.separator + 'classes'
//                }
//            }
//        }

    
    
        def sout = new StringBuilder(), serr = new StringBuilder()
        def proc = '/usr/bin/java -jar path/MakePublicUnfinal.main.jar --inClassDir /path/to/your/project/build/intermediates/javac --outClassDir /path/to/your/project/app/build/intermediates/javac'.execute()
        proc.consumeProcessOutput(sout, serr)
        proc.waitForOrKill(10000)
        if (0 != proc.exitValue()) {
            throw new GradleException($serr)
        }
    }
}


tasks.whenTaskAdded { task ->
    if (task.name.startsWith("compile") && task.name.endsWith("JavaWithJavac")) {
        task.dependsOn(publicAndUnFinal)
        logger.lifecycle("Task injected: " + task.name)
    }
}
```



## How do I copy all dependencied?
like Maven's copy-dependencides
```
//copy paste from https://proandroiddev.com/how-to-extract-your-android-projects-dependencies-with-a-gradle-task-1775e8c21093
android.applicationVariants.all { variant ->
    task "copyDependencies${variant.name.capitalize()}"() {
        outputs.upToDateWhen { false }
        doLast {
            println "Executing copyDependencies${variant.name.capitalize()}"
            variant.getCompileClasspath().each { fileDependency ->
                def sourcePath = fileDependency.absolutePath
                def destinationPath = project.projectDir.path + "/build/dependencies/${variant.name}/"
                println "Copying dependency:"
                println sourcePath

//The monstrous regex that gets the name of the lib from itâ€™s exploded .aar path
                def dependencyName
                if (sourcePath.contains("classes.jar")) {
                    def dependencyNameRegexResult = (sourcePath =~ /.*\/(.*)\.aar\/.*\/jars\/classes\.jar/)
                    if (dependencyNameRegexResult.size() > 0) {
                        dependencyName = dependencyNameRegexResult[0][1]
                        println "Exploded AAR found : ${dependencyName}"
                    }
                }

                copy {
                    from sourcePath
                    into destinationPath

                    rename {String filename ->
                        if (filename.contains("classes.jar") && dependencyName != null) {
                            dependencyName = "${dependencyName}.jar"
                            println "Renaming dependency file to : ${dependencyName}"
                            return dependencyName
                        }
                        return filename
                    }
                }
            }
        }
    }
}

```